{"ast":null,"code":"// src/data/posts.ts\n\nexport const posts = [{\n  id: \"why-typed-apis\",\n  title: \"為什麼我用 Typed API：從前端 DX 到後端可靠性\",\n  date: \"2025-08-10\",\n  tags: [\"TypeScript\", \"API\", \"DX\"],\n  excerpt: \"型別不只是補救錯誤，它影響協作速度、邊界設計與可維護性。我在三個專案裡的實戰筆記。\",\n  content: `型別的價值常被誤解為“多寫幾個字”。但在多人協作的產品開發中，\n它其實是“溝通介面”的一部分。這篇文章從三個面向談我如何逐步把後端契約前移，\n用 Typed API 提升開發效率與可靠性。\n\n一、溝通成本：規格先行\n我習慣在需求模糊期先用 Zod/TypeBox 定義資料結構，與 PM/設計師同步，\n這讓我在前端可以先 stub 出 UI，不必等到後端上線。\n\n二、回歸點：錯誤落在 compile-time\n很多 runtime 才發現的錯，提早在編譯時阻擋，PR review 的討論品質也提高。\n\n三、部署後：日誌+型別做為迭代證據\n當資料結構演進時，我用 codemod+型別狀態拆遷移步驟，降低風險。`\n}, {\n  id: \"react-performance-notes\",\n  title: \"React 效能筆記：從 120ms 到 16ms 的旅程\",\n  date: \"2025-07-30\",\n  tags: [\"React\", \"Performance\"],\n  excerpt: \"一次表單渲染卡頓的救援：Profiler、分段渲染、避免不必要的 re-render。\",\n  content: `我們的管理介面在表單切換時會卡住。我用 React Profiler 發現是 context 改變\n導致的大量無關 re-render。調整策略如下：\n\n1) 切分 Context：把高頻變動的 state 下放更靠近使用者的 component。\n2) memo + useCallback：只在必要時穩定參考。\n3) skeleton + 分段渲染：先出可見區，再載入次要欄位。\n\n最後首屏互動時間從 120ms 降到 16ms，用戶的體感差非常多。`\n}];","map":{"version":3,"names":["posts","id","title","date","tags","excerpt","content"],"sources":["C:/Users/Louis/Downloads/react-portfolio/src/data/posts.ts"],"sourcesContent":["// src/data/posts.ts\r\nexport type Post = {\r\n  id: string;\r\n  title: string;\r\n  date: string;     // ISO or readable string\r\n  tags: string[];\r\n  excerpt: string;  // 卡片上顯示的摘要\r\n  content: string;  // 內文（可用 \\n\\n 分段）\r\n};\r\n\r\nexport const posts: Post[] = [\r\n  {\r\n    id: \"why-typed-apis\",\r\n    title: \"為什麼我用 Typed API：從前端 DX 到後端可靠性\",\r\n    date: \"2025-08-10\",\r\n    tags: [\"TypeScript\", \"API\", \"DX\"],\r\n    excerpt:\r\n      \"型別不只是補救錯誤，它影響協作速度、邊界設計與可維護性。我在三個專案裡的實戰筆記。\",\r\n    content:\r\n      `型別的價值常被誤解為“多寫幾個字”。但在多人協作的產品開發中，\r\n它其實是“溝通介面”的一部分。這篇文章從三個面向談我如何逐步把後端契約前移，\r\n用 Typed API 提升開發效率與可靠性。\r\n\r\n一、溝通成本：規格先行\r\n我習慣在需求模糊期先用 Zod/TypeBox 定義資料結構，與 PM/設計師同步，\r\n這讓我在前端可以先 stub 出 UI，不必等到後端上線。\r\n\r\n二、回歸點：錯誤落在 compile-time\r\n很多 runtime 才發現的錯，提早在編譯時阻擋，PR review 的討論品質也提高。\r\n\r\n三、部署後：日誌+型別做為迭代證據\r\n當資料結構演進時，我用 codemod+型別狀態拆遷移步驟，降低風險。`\r\n  },\r\n  {\r\n    id: \"react-performance-notes\",\r\n    title: \"React 效能筆記：從 120ms 到 16ms 的旅程\",\r\n    date: \"2025-07-30\",\r\n    tags: [\"React\", \"Performance\"],\r\n    excerpt:\r\n      \"一次表單渲染卡頓的救援：Profiler、分段渲染、避免不必要的 re-render。\",\r\n    content:\r\n      `我們的管理介面在表單切換時會卡住。我用 React Profiler 發現是 context 改變\r\n導致的大量無關 re-render。調整策略如下：\r\n\r\n1) 切分 Context：把高頻變動的 state 下放更靠近使用者的 component。\r\n2) memo + useCallback：只在必要時穩定參考。\r\n3) skeleton + 分段渲染：先出可見區，再載入次要欄位。\r\n\r\n最後首屏互動時間從 120ms 降到 16ms，用戶的體感差非常多。`\r\n  }\r\n];\r\n"],"mappings":"AAAA;;AAUA,OAAO,MAAMA,KAAa,GAAG,CAC3B;EACEC,EAAE,EAAE,gBAAgB;EACpBC,KAAK,EAAE,+BAA+B;EACtCC,IAAI,EAAE,YAAY;EAClBC,IAAI,EAAE,CAAC,YAAY,EAAE,KAAK,EAAE,IAAI,CAAC;EACjCC,OAAO,EACL,2CAA2C;EAC7CC,OAAO,EACL;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,EACD;EACEL,EAAE,EAAE,yBAAyB;EAC7BC,KAAK,EAAE,+BAA+B;EACtCC,IAAI,EAAE,YAAY;EAClBC,IAAI,EAAE,CAAC,OAAO,EAAE,aAAa,CAAC;EAC9BC,OAAO,EACL,6CAA6C;EAC/CC,OAAO,EACL;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,CACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}